# 五十四 进程的创建方法
## 54.1. 面向过程式创建
```python
import time
from multiprocessing import Process


def task(name: str):
    print(f"{name} 进程以创建")
    time.sleep(3)
    print(f"{name} 进程结束")


if __name__ == '__main__':
    Process(target=task, args=("小华",)).start()
    print("主进程结束")
```
> 1. Windows操作系统，创建进程是以模块导入的形式创建
> 2. Linux/Unix系统，创建进程是完成的复制一份代码进行创建

**python中进程使用的类或方法**
首先导入提供进程支持的模块`multiprocessing`
1. `multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)`
    > 1. `group`:  `group` 应该始终是 `None`；它仅用于兼容 `threading.Thread` target 是由 `run()` 方法调用的可调用对象
    > 2. `target`: 提交的进程中执行的目标
    > 3. `name`: 进程名称
    > 4. `args`: 传入到target中的位置参数,始终是一个元组
    > 5. `kwargs`: 传入到target中的关键字参数, 字典 
    > 6. `daemon`: `True`或`False`(是否为守护进程), 默认为None表示从创建的进程继承<br><br>
    **默认情况下，不会将任何参数传递给 target**
    
**Process对象的方法和属性**

1. `run()`: 表示进程活动的方法
2. `start()`: 启动进程活动
3. `join([timeout])`: 如果可选参数 timeout 是 None （默认值），则该方法将阻塞，直到调用 `join()` 方法的进程终止

    进程无法`join`自身，因为这会导致**死锁**。尝试在启动进程之前`join`进程是错误的
4. `name`: 进程的名称。该名称是一个字符串，仅用于识别目的
5. `is_alive()`: 返回进程是否还活着
6. `daemon`: 进程的守护标志，一个布尔值. 这必须在 `start()` 被调用之前设置, 初始值继承自创建进程


## 54.2 面向对象的方式创建进程
1. 继承`Process`类
2. 重写`__init__`方法(可以不重写)
3. 重写`run()`方法(必须重写)
```python
import multiprocessing
import time

class MyProcess_1(multiprocessing.Process):
    def __init__(self, *args, **kwargs):
        super().__init__()
        self.args = args
        self.kwargs = kwargs

    @staticmethod
    def sing():
        for i in range(10):
            time.sleep(1)
            print("我唱歌---%d" % (i +1))

    def run(self):
        self.sing()

class MyProcess_2(multiprocessing.Process):
    def __init__(self, *args, **kwargs):
        super().__init__()
        self.args = args
        self.kwargs = kwargs

    @staticmethod
    def dance():
        for i in range(10):
            time.sleep(1)
            print("我跳舞---%d" % (i + 1))

    def run(self):
        self.dance()

MyProcess_1().start()

MyProcess_2().start()
```












