# 十八、名称空间
&emsp;&emsp;命名空间(Namespace)是从**名称到对象的映射**，大部分的命名空间都是通过*Python*字典来实现的。<br>
&emsp;&emsp;命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以同一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。

**一般有三种名称空间**
1. *内置名称*（built-in names）， Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。
2. *全局名称*（global names），模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。
3. *局部名称*（local names），函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）

![名称空间](https://images.gitee.com/uploads/images/2020/0728/234224_42fbb049_7841459.png "名称空间")

**命名空间查找顺序**

&emsp;&emsp;假设我们要使用变量`runoob`，则`Python`的查找顺序为:<span style="color: red;">局部的命名空间去 -> 全局命名空间 -> 内置命名空间</span>。<br>
&emsp;&emsp;如果找不到变量`runoob`，它将放弃查找并引发一个`NameError`异常:


**名称空间的生命周期**

&emsp;&emsp;命名空间的生命周期*取决于对象的作用域*，如果对象执行完成，则该命名空间的生命周期就结束。<br>
&emsp;&emsp;因此，我们无法从外部命名空间访问内部命名空间的对象。

1. **内置名称空间**: python解释器启动时, 内置名称空间就会建立, 在python解释器结束运行时回收
2. **全局名称空间**: python程序执行建立全局名称空间, python程序结束时回收.
3. **局部名称空间**: 当函数被调用、类被定义、模块被导入时，建立局部名称空间 

**python中能产生名称空间的关键字**
1. `def` 定义函数
2. `class` 定义类
3. `import` 导入的模块

以上三个关键字才会产生名称空间, 而且均产生局部名称空间

# 十九、作用域
作用域就是一个**Python**程序可以 *直接* 访问命名空间的正文区域。

在一个**python**程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。

**Python**中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。

变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称. **Python**的作用域一共有$4$种.
1. `L（Local）`：最内层，包含局部变量，比如一个函数/方法内部。
2. `E（Enclosing）`：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。
3. `G（Global）`：当前脚本的最外层，比如当前模块的全局变量。
4. `B（Built-in）`： 包含了内建的变量/关键字等。，最后被搜索

**作用域搜索顺序**

![作用域搜索顺序](https://images.gitee.com/uploads/images/2020/0729/154653_0c1b3fef_7841459.png "在这里输入图片标题")


**全局作用域和局部作用域**
1. `全局作用域`: 包含内置名称空间和全局名称空间
2. `局部作用域`: 包含局部作用域














