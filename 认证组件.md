# 一、认证(Authentication)
认证，校验登录状态

## 1.1 Authentication源码分析
认证是在`APIView`类种的`dispatch`方法中认证的`self.initial(request, *args, **kwargs)`方法中进行认证的

```python
def initial(self, request, *args, **kwargs):
    # Ensure that the incoming request is permitted
    self.perform_authentication(request)  # 认证
    self.check_permissions(request)  # 权限
    self.check_throttles(request)  # 频率
```
下面看`self.perform_authentication(request)`方法的源码
```python
def perform_authentication(self, request):
    request.user  # 在drf封装的request对象中
```
在Request类种查找`user`属性或方法查看认证原理
```python
def user(self):
    if not hasattr(self, '_user'):  # 判断request中是否有_user属性
        with wrap_attributeerrors():
            self._authenticate()  # 没有，执行此方法
    return self._user  # 有，返回用户
```
查看`Request`类种的`_authenticate()`方法(核心认证方法)
```python
def _authenticate(self):
    for authenticator in self.authenticators:  # self.authenticators = authenticators or () 是在Request类实例化是传入的认证类的对象。没次循环都会拿到一个认证类的对象
        try:
            user_auth_tuple = authenticator.authenticate(self)  # 认证对象的authenticate方法。该方法要返回两个值， self就是request
        except exceptions.APIException:  # 认证失败，抛出异常
            self._not_authenticated()
            raise

        # 返回值的处理
        if user_auth_tuple is not None:
            self._authenticator = authenticator
            self.user, self.auth = user_auth_tuple  # self是Request的对象
            return

    self._not_authenticated()  # 没有返回值，代表游客认证通过
```

* `self.authenticators`是Request类实例化是传入的。而Request类是在`APIView`的`dispatch`方法中实例化的。
    ```python
    request = self.initialize_request(request, *args, **kwargs)  # Request类的实例化
    ```
    查看`initialize_request`方法
    ```python
    
    def initialize_request(self, request, *args, **kwargs):
        parser_context = self.get_parser_context(request)
    
        return Request(
            request,
            parsers=self.get_parsers(),
            authenticators=self.get_authenticators(),  # 认证类的对象
            negotiator=self.get_content_negotiator(),
            parser_context=parser_context
        )
    ```
    查看`get_authenticators`方法
    ```python
    def get_authenticators(self):
        # 返回的是认证类的对象
        return [auth() for auth in self.authentication_classes]
    ```
    `self.authentication_classes`是视图类的属性, 在`APIView`类属性中也有。对于继承了`APIView`中子类，都可以重写此属性。它是一个可迭代对象。
    

## 1.2 Authentication实现
* 第一步，写一个认证类，继承BaseAuthentication类
* 第二步，重写authenticate方法，里面是认证逻辑
    * 认证通过，返回两个值，被Request类的对象user属性和auth属性接受
    * 认证失败，抛出异常，`APIException`或`AuthenticationFailed`异常，其中`AuthenticationFailed`异常是继承`APIException`
* 第三步，在视图类重写`authentication_classes`属性，此属性是一个列表，保存的是认证类

* 模型类
    ```python
    class User(models.Model):
        username = models.CharField(max_length=32)
        password = models.CharField(max_length=32)
        choices = [(1, '超级用户'),
                   (2, '普通用户'),
                   (3, '二级用户')
                   ]
        user_type = models.SmallIntegerField(choices=choices)
    
    
    class UserToken(models.Model):
        token = models.CharField(max_length=64)
        user = models.OneToOneField(to='User', on_delete=models.CASCADE, to_field='id')
    ```
* 登录视图
    ```python
    class LoginView(APIView):
        """
        登录
        """
    
        def post(self, request):
            username = request.data.get("username")
            password = request.data.get("password")
            user = models.User.objects.filter(username=username, password=password).first()
            if user:
                # 登录成功, 生成随机字符串
                token_string = uuid.uuid4()
                # 存入usertoken表中
                # models.UserToken.objects.create(token=token_string, user=user)  # 没次登录都会记录一条，容易造成数据冗余
                models.UserToken.objects.update_or_create(defaults={'token': token_string}, user=user)  # 有则更新，无则新增
                # 使用user取查询，使用default更新
                return Response({"status": 100, 'msg': '登录成功', 'token': token_string})
    
            return Response({'status': 101, 'msg': '用户名或密码错误'})
    ```
* 登录路由
    ```python
    path('login/', views.LoginView.as_view()),
    ```
* 认证逻辑 `app/authenticate.py`种写如下代码
    ```python
    from rest_framework.authentication import BaseAuthentication
    from rest_framework.exceptions import AuthenticationFailed
    from . import models
    
    class Authenticate(BaseAuthentication):
        """
        认证类
        """
        def authenticate(self, request):
            """
            认证逻辑，必须重写
            """
            token = request.query_params.get('token')
            if token:
                user_token = models.UserToken.objects.filter(token=token).first()
                if user_token:
                    # 认证通过，返回两个值
                    return user_token.user, token
                # 认证失败，抛出异常
                raise AuthenticationFailed("认证失败")
    
            raise AuthenticationFailed("缺少认证")
    ```
* 配置
    * 局部配置, 在要认证的视图类种添加属性`authentication_classes = [AuthenticateClass]`
    * 全局配置，在`settings.py`添加
        ```python
        REST_FRAMEWORK={
            "DEFAULT_AUTHENTICATION_CLASSES":["app01.service.authenticate.Authenticate",]
        }
        ```

## 1.3 认证源码流程分析







# 二、权限(Permissions)



# 三、频率(Throttling)