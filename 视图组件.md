# 一、`DRF`视图类
## 1.1 `APIView`视图基类
是`DRF`提供的所有视图基类，继承自`Django`的`View`父类

* 与`View`视图类的区别
    * `request`的不同
        * `APIView`传递进入视图方法的`request`是`DRF`封装的`Request`对象
        * `View`传递进入视图方法的`request`是`Django`提供的`HttpRequest`对象
    * 视图方法可以返回`REST framework`的`Response`对象，视图会为响应数据设置`（render）`符合前端要求的格式
    * 任何`APIException`异常都会被捕获到，并且处理成合适的响应信息
    * 在进行`dispatch()`分发前，会对请求进行身份认证、权限检查、流量控制

* 支持定义的属性
    * `authentication_classes`: 列表或元祖，身份认证类
    * `permission_classes`: 列表或元祖，权限检查类
    * `throttle_classes`: 列表或元祖，流量控制类

在`APIView`中仍以常规的类视图定义方法来实现`get()`, `post()`或者其他请求方式的方法

**基于APIView实现接口**
```python
# 基于APIView实现接口
class BookView(APIView):
    """
    获取所有图书的视图类
    """
    def get(self, request):
        """
        获取所有图书的接口
        :param request:
        :return:
        """
        book_list = models.Book.objects.all()
        book_serializer = serializers.BookModelSerializer(book_list, many=True)
        return Response(book_serializer.data)

    def post(self, request):
        """
        新增图书接口
        :param request:
        :return:
        """
        book_serializer = serializers.BookModelSerializer(data=request.data)
        if book_serializer.is_valid():
            book_serializer.save()
            return Response(book_serializer.data)

        return Response({'status': 101, 'msg': '数据新增错误'})


class BookDetailView(APIView):
    def get(self, request, pk):
        """
        获取一条数据
        :param request:
        :param pk:
        :return:
        """
        book = models.Book.objects.filter(pk=pk).first()
        book_serializer = serializers.BookModelSerializer(book)
        return Response(book_serializer.data)

    def put(self, request, pk):
        """
        修改一条数据
        :param request:
        :param pk:
        :return:
        """
        book = models.Book.objects.filter(pk=pk).first()
        book_serializer = serializers.BookModelSerializer(instance=book, data=request.data)
        if book_serializer.is_valid():
            book_serializer.save()
            return Response(book_serializer.data)
        return Response({"status": 101, 'msg': '数据修改失败'})

    def delete(self, request, pk):
        """
        删除数据
        :param request:
        :param pk:
        :return:
        """
        models.Book.objects.filter(pk=pk).delete()
        return Response({"status": 100, 'msg': '删除成功'})
```

## 1.2 `GenericAPIView`视图类
继承自`APIVIew`，主要增加了操作序列化器和数据库查询的方法，作用是为下面`Mixin`扩展类的执行提供方法支持。通常在使用时，可搭配一个或多个`Mixin`扩展类。
```python
from rest_framework.generics import GenericAPIView
```

* 序列化器使用的属性和方法
    * `serializer_class = 序列化类`: 指明视图使用的序列化器
    * `get_serializer_class(self)`: 获取序列化器
        * 当出现一个视图类中调用多个序列化器时,那么可以通过条件判断在`get_serializer_class`方法中通过返回不同的序列化器类名就可以让视图方法执行不同的序列化器对象了。
        * 支持重写
    * `get_serializer(self, args, *kwargs)`: 返回序列化器对象
        * **该方法在提供序列化器对象的时候，会向序列化器对象的`context`属性补充三个数据：`request`、`format`、`view`，这三个数据对象可以在定义序列化器时使用**
            * `request`: 当前视图的请求对象
            * `view`: 当前请求的类视图对象
            * `format`: 当前请求期望返回的数据格式 
            
* 数据库查询的属性与方法
    * `queryset`: 指明使用的数据查询集
    * `get_queryset(self)`: 返回视图使用的查询集
    * `get_object(self)`: 返回视图所需的模型类数据对象
        * 若详情访问的模型类对象不存在，会返回404。
       
* 其他可以设置的属性
    * `pagination_class`: 指明分页控制类
    * `filter_backends`: 指明过滤控制后端

* GenericAPIView使用
    ```python
    # 基于GenericAPIView的视图函数类
    class GenericBookView(GenericAPIView):
        queryset = models.Book.objects  # 数据集
        serializer_class = serializers.BookModelSerializer  # 视图需要的序列化器
    
        def get(self, request):
            """
            获取所有数据
            :return:
            """
            book_list = self.get_queryset()
            book_serializer = self.get_serializer(book_list, many=True)
            return Response(book_serializer.data)
    
        def post(self, request):
            """
            新增数据
            :param request:
            :return:
            """
            book_serializer = self.get_serializer(data=request.data)
            if book_serializer.is_valid():
                book_serializer.save()
                return Response(book_serializer.data)
    
            return Response({'status': 101, 'msg': '数据新增错误'})
    
    
    class GenericBookDetailView(GenericAPIView):
        queryset = models.Book.objects.all()
        serializer_class = serializers.BookModelSerializer
    
        def get(self, request, pk):
            """
            获取一条数据
            :param request:
            :param pk:
            :return:
            """
            book = self.get_object()
            book_serializer = self.get_serializer(book)
            return Response(book_serializer.data)
    
        def put(self, request, pk):
            """
            修改一条数据
            :param request:
            :param pk:
            :return:
            """
            book = self.get_object()
            book_serializer = self.get_serializer(instance=book, data=request.data)
            if book_serializer.is_valid():
                book_serializer.save()
                return Response(book_serializer.data)
            return Response({"status": 101, 'msg': '数据修改失败'})
    
        def delete(self, request, pk):
            """
            删除数据
            :param request:
            :param pk:
            :return:
            """
            models.Book.objects.filter(pk=pk).delete()
            return Response({"status": 100, 'msg': '删除成功'})
    ```

## 1.3 `GenericAPIView`视图扩展类
提供了几种后端视图（对数据资源进行曾删改查）处理流程的实现，如果需要编写的视图属于这五种，则视图可以通过继承相应的扩展类来复用代码，减少自己编写的代码量。
```python
from rest_framework.mixins import ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin
```

这五个扩展类需要搭配`GenericAPIView`父类，因为五个扩展类的实现需要调用`GenericAPIView`提供的序列化器与数据库查询的方法

### 1.3.1 `ListModelMixin` 列表扩展类(查询全部数据)
提供list(request, *args, **kwargs)方法快速实现列表视图，返回200状态码。

该Mixin的list方法会对数据进行过滤和分页。
* 源码
    ```python
    class ListModelMixin:
        """
        List a queryset.
        """
        def list(self, request, *args, **kwargs):
            # 过滤
            queryset = self.filter_queryset(self.get_queryset())
            # 分页
            page = self.paginate_queryset(queryset)
            if page is not None:
                serializer = self.get_serializer(page, many=True)
                return self.get_paginated_response(serializer.data)
    
            serializer = self.get_serializer(queryset, many=True)
            return Response(serializer.data)
    ```
* 使用
    ```python
    class GenericBookView(ListModelMixin, GenericAPIView):
        queryset = models.Book.objects
        serializer_class = serializers.BookModelSerializer
    
        def get(self, request):
            """
            获取所有数据
            :return:
            """
            # book_list = self.get_queryset()
            # book_serializer = self.get_serializer(book_list, many=True)
            # return Response(book_serializer.data)
            return self.list(request=request)
    ```
        