# 六十一、线程通信
* 因为线程属于同一个进程，因此它们之间共享内存区域。
* 因此全局变量是公共的。
* 对于全局变量每个线程对其的操作会存在竞争。
* 使用 **锁** 来控制共享资源的访问

**互斥锁**

```python
import threading

x = 0
n = 10 ** 6
lock = threading.Lock()  # 生成锁


def fun_1(n):
    global x
    for i in range(n):
        lock.acquire()  # 加锁
        x += 1
        lock.release()  # 解锁


def fun_2(n):
    global x
    for i in range(n):
        lock.acquire()  # 加锁
        x -= 1
        lock.release()  # 解锁


thread_1 = threading.Thread(target=fun_1, args=(n,))
thread_2 = threading.Thread(target=fun_2, args=(n,))
thread_1.start()
thread_2.start()
thread_1.join()
thread_2.join()

print(x)
```
> 1. 不加锁的情况下，两个线程会存在数据争抢的情况，
> 2. 而且线程会被操作系统不停的切换。有时候可能数据还没来的及更改，线程就被切换了。
> 3. 线程再次被切换回来后，之前获取到数据可能已经发生更改。造成数混乱的情况
> 4. 使用`with`语句，可以让程序自动上锁和解锁


# **全局解释器锁GIL**
**GIL全局解释器锁是`Cpython`解释器的遗留下来的，不是python的这门编程语言的特点**
****
**在Cpython中，GIL是一把互斥锁，用于阻止同一个进程先的多个线程同时执行.*也就是同一进程下的多线程无法利用多核优势***
> 1. `计算密集型`: `CPU`会一直处于计算状态，
> 2. `IO密集型`: `CPU`会有大量的时间处于空闲状态，等待IO操作完成。
> * **计算密集型** 的任务，对于多核`CPU`，使用多线程
> * **IO密集型** 的任务，对于多核`CPU`，使用多线程

**计算密集型任务**
```python
import time
from threading import Thread
from multiprocessing import Process, cpu_count

# 计算密集型任务，开设多进程和多线程
def work():
    res = 1
    for i in range(10 ** 7):
        res *= i

if __name__ == '__main__':

    # 开设4个进程
    l = []
    start_time = time.time()
    for i in range(cpu_count()):
        # p = Process(target=work)  # 多进程需要1.2896361351013184
        # p.start()
        # l.append(p)
        t = Thread(target=work)  # 多线程需要 2.3009190559387207
        t.start()
        l.append(t)

    for p in l:
        p.join()
    print(time.time() - start_time)
```
> 1. 计算密集型任务，多线程处于并行状态，需要时间会更加的多
> 2. 使用多线程会使计算密集型任务并行运行，降低执行时间

**IO密集型任务**
```python
import time
from threading import Thread
from multiprocessing import Process, cpu_count


def work_io():
    time.sleep(2)

if __name__ == '__main__':

    # 开设4个进程
    l = []
    start_time = time.time()
    for i in range(cpu_count()):
      
        # io密集型
        # p = Process(target=work_io)  # 多进程使用时间 2.2516634464263916
        # p.start()
        # l.append(p)

        t = Thread(target=work_io)  # 多线程使用时间 2.0163824558258057
        t.start()
        l.append(t)

    for p in l:
        p.join()
    print(time.time() - start_time)

```
> 1. `io`密集型任务，开设多线程或多进程消耗的时间相差不多
> 2. 但是开始进程消耗的系统资源更大
> 3. 当开始进程超过cpu核心数后，进程消耗的时间要比线程消耗的时间大很多

****
**原因: `Cpython`中的内存管理(垃圾回收机制)不是线程安全的**

**GIL全局解释器锁保证了解释器级别的数据安全**

# **`GIL`与互斥锁**
1. 线程创建后，会先获取`GIL`
2. 当线程进入`IO`操作后，会自动释放`GIL`
3. 互斥锁是由线程决定的
****
# 死锁
程序中使用锁过于的的情况会容易造成程序卡死(阻塞)

```python
from threading import Thread, Lock
import time

loc1 = Lock()  # 生成锁1
loc2 = Lock()  # 生成锁2


class MyThread(Thread):
    def run(self):
        self.func1()
        self.func2()

    def func1(self):
        loc1.acquire()  # 枪锁1
        print("线程%s 抢到锁loc1" % self.name)
        loc2.acquire()  # 枪锁2
        print("线程%s 抢到锁loc2" % self.name)
        loc2.release()  # 释放锁2
        loc1.release()  # 释放锁1

    def func2(self):
        loc2.acquire()  # 枪锁2
        print("线程%s 抢到锁loc2" % self.name)
        time.sleep(2)
        loc1.acquire()  # 枪锁1
        print("线程%s 抢到锁loc1" % self.name)
        loc1.release()  # 释放锁1
        loc2.release()  # 释放锁2


if __name__ == '__main__':
    for i in range(10):
        t = MyThread()
        t.start()
```
> 1. 程序开启了10个线程，假设`Thread-1`抢到`GIL`则`Thread-1`开始执行
> 2. `Thread-1`先执行`func1`，它可以顺利抢到`loc1`，没有线程和他争抢，顺利执行下去.
> 3. `Thread-1`执行到`func2`，还没有线程和它抢锁，也可以顺利拿到`loc2`，此时`Thread-1`遇到阻塞，此时释放`GIL`, 切换线程. 此时假设`Thread-2`抢到`GIL`，线程`Thread-2`开始执行
> 4. `Thread-2`此时也没有其他线程给他竞争锁`loc1`, 开始执行，当`Thread-2`要开始抢锁`loc2`时，`Thread-1`持有锁`loc2`还未释放，会导致`Thread-2`阻塞。此时，释放`GIL`。此时唯有的两把锁被线程`Thread-1`和`Thread-2`占据。就算其他线程抢到了`GIL`，也不会获取到`loc1`和`loc2`，导致其他线程不会执行。会立即切换
> 5. 不妨假设就切换到了线程`Thread-1`，此时`Thread-1`需要获取锁`loc1`, 但是此时锁`loc1`还被线程`Thread-2`占居。这样就导致了程序阻塞
****
# 递归锁

当递归锁被一个线程或进程获取到后，这个线程或进程可以 **连续** 的`acquire`和`release`，
> 1. 锁的内部有一个计数器, 当被`acquire`一次，计数器`+1`; 被`release`一次，计数器`-1`
> 2. **只要计数器不为`0`, 其他的线程或进程都不能获取到这把锁** 

```python
from threading import Thread, RLock
import time


loc1 = loc2 = RLock()


class MyThread(Thread):
    def run(self):
        self.func1()
        self.func2()

    def func1(self):
        loc1.acquire()  # 枪锁1
        print("线程%s 抢到锁loc1" % self.name)
        loc2.acquire()  # 枪锁2
        print("线程%s 抢到锁loc2" % self.name)
        loc2.release()  # 释放锁2
        print("线程%s 释放锁loc2" % self.name)
        loc1.release()  # 释放锁1
        print("线程%s 释放锁loc1" % self.name)

    def func2(self):
        loc2.acquire()  # 枪锁2
        print("线程%s 抢到锁loc2" % self.name)
        time.sleep(2)
        loc1.acquire()  # 枪锁1
        print("线程%s 抢到锁loc1" % self.name)
        loc1.release()  # 释放锁1
        print("线程%s 释放锁loc1" % self.name)
        loc2.release()  # 释放锁2
        print("线程%s 释放锁loc2" % self.name)


if __name__ == '__main__':
    for i in range(10):
        t = MyThread()
        t.start()


```

****
# 信号量
**信号量在并发中是指的锁**
* 信号量`semaphore`可以控制同时运行执行的线程数量。
* 信号量`semaphore`内部维护了一个条件变量和一个计数器。

```python
from threading import Thread, Semaphore, current_thread
import time
import random

sm = Semaphore(5)  # 每次能够运行的线程


def task():
    sm.acquire()
    print(f"{current_thread().name}正在运行: {time.time()} ")
    time.sleep(random.randint(2, 4))
    print(f"{current_thread().name}结束: {time.time()} ")
    sm.release()


if __name__ == '__main__':
    for i in range(20):
        t = Thread(target=task)
        t.start()
```

# `Event`事件

# 线程`Q`




